"""
Security utilities for JWT tokens and password hashing
"""
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.core.config import settings
from typing import Optional
import base64
try:
    from cryptography.fernet import Fernet, InvalidToken  # type: ignore
except Exception:  # pragma: no cover - cryptography optional at import time
    Fernet = None  # type: ignore
    InvalidToken = Exception  # type: ignore

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against a hash"""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token"""
    if not settings.JWT_SECRET_KEY:
        raise ValueError("JWT_SECRET_KEY is not set. Please set the JWT_SECRET_KEY environment variable.")
    
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES
        )
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM
    )
    return encoded_jwt


def decode_access_token(token: str) -> Optional[dict]:
    """Decode and verify a JWT token"""
    if not settings.JWT_SECRET_KEY:
        return None
    
    try:
        payload = jwt.decode(
            token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM]
        )
        return payload
    except JWTError:
        return None


# Secret encryption helpers
_fernet_instance: Optional["Fernet"] = None


def _get_fernet() -> "Fernet":
    """
    Get a cached Fernet instance using SECRETS_ENCRYPTION_KEY.
    Raises a clear error if cryptography or key are not configured.
    """
    global _fernet_instance
    if _fernet_instance is not None:
        return _fernet_instance
    if Fernet is None:
        raise RuntimeError("cryptography is required for secret encryption. Please install 'cryptography'.")
    key = settings.SECRETS_ENCRYPTION_KEY
    if not key:
        raise RuntimeError("SECRETS_ENCRYPTION_KEY is not set. Set a Fernet key in the environment.")
    # Validate/normalize key
    try:
        # If not urlsafe base64, attempt to decode/encode to validate
        base64.urlsafe_b64decode(key)
    except Exception:
        raise RuntimeError("SECRETS_ENCRYPTION_KEY must be a 32-byte url-safe base64-encoded key generated by Fernet.")
    _fernet_instance = Fernet(key)  # type: ignore[arg-type]
    return _fernet_instance


def encrypt_secret(plaintext: Optional[str]) -> Optional[str]:
    """
    Encrypt a plaintext secret using Fernet; returns a string prefixed with 'enc:'.
    Returns None when plaintext is falsy.
    """
    if not plaintext:
        return None
    f = _get_fernet()
    token = f.encrypt(plaintext.encode("utf-8"))
    return f"enc:{token.decode('utf-8')}"


def decrypt_secret(ciphertext: Optional[str]) -> Optional[str]:
    """
    Decrypt a ciphertext produced by encrypt_secret. Returns None when input is falsy.
    """
    if not ciphertext:
        return None
    if not ciphertext.startswith("enc:"):
        # Backward compatibility (stored as plain text) - return as-is
        return ciphertext
    f = _get_fernet()
    ct = ciphertext[4:].encode("utf-8")
    try:
        pt = f.decrypt(ct)
        return pt.decode("utf-8")
    except InvalidToken:
        raise RuntimeError("Failed to decrypt secret: invalid token or key.")

